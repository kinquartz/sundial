/**
  * Generated by API Builder - https://www.apibuilder.io
  * Service version: 0.1.3
  * apibuilder:0.12.38 https://app.apibuilder.io/gilt/svc-sundial/0.1.3/play_2_x_json
  */
package com.gilt.svc.sundial.v0.models {

  sealed trait Notification extends _root_.scala.Product with _root_.scala.Serializable

  /**
    * A specification for when a process should be run
    */
  sealed trait ProcessSchedule extends _root_.scala.Product with _root_.scala.Serializable

  sealed trait TaskExecutable extends _root_.scala.Product with _root_.scala.Serializable

  /**
    * @param jobQueue Override default job queue, eg: for priority queue or GPU
    * instances queue
    * @param image Name of docker image including registry URL if needed
    * @param tag Tag on docker image
    * @param environmentVariables environment variables to be passed to container
    * @param command Command to pass to Docker container
    * @param jobRoleArn ARN of an IAM role, see
    * http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html
    * @param vCpus
    * @param memory
    */
  case class BatchImageCommand(
                                image: String,
                                tag: String = "latest",
                                command: Seq[String],
                                memory: Int,
                                vCpus: Int,
                                jobRoleArn: _root_.scala.Option[String] = None,
                                environmentVariables: Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable] = Nil,
                                jobQueue: _root_.scala.Option[String] = None
                              ) extends TaskExecutable

  /**
    * @param bufferSeconds The minimum amount of time (in seconds) that must pass
    * between executions of the process
    */
  case class ContinuousSchedule(
                                 bufferSeconds: _root_.scala.Option[Int] = None
                               ) extends ProcessSchedule

  /**
    * See http://quartz-scheduler.org/api/2.2.0/org/quartz/CronExpression.html
    */
  case class CronSchedule(
                           dayOfWeek: String,
                           month: String,
                           dayOfMonth: String,
                           hours: String,
                           minutes: String
                         ) extends ProcessSchedule

  case class DockerImageCommand(
                                 image: String,
                                 tag: String = "latest",
                                 command: Seq[String],
                                 memory: _root_.scala.Option[Int] = None,
                                 cpu: _root_.scala.Option[Int] = None,
                                 taskRoleArn: _root_.scala.Option[String] = None,
                                 logPaths: Seq[String] = Nil,
                                 environmentVariables: Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable] = Nil
                               ) extends TaskExecutable

  /**
    * An email to send notifications to
    */
  case class Email(
                    name: String,
                    email: String,
                    notifyWhen: com.gilt.svc.sundial.v0.models.NotificationOptions = com.gilt.svc.sundial.v0.models.NotificationOptions.OnStateChangeAndFailures
                  ) extends Notification

  case class EnvironmentVariable(
                                  variableName: String,
                                  value: String
                                )

  case class Healthcheck(
                          status: String
                        )

  /**
    * @param logEntryId Uniquely identifies the log message to prevent duplication
    * @param when
    * @param source
    * @param message
    */
  case class LogEntry(
                       logEntryId: _root_.java.util.UUID,
                       when: _root_.org.joda.time.DateTime,
                       source: String,
                       message: String
                     )

  /**
    * @param metadataEntryId Uniquely identifies the metadata entry to prevent
    * duplication
    * @param when
    * @param key
    * @param value
    */
  case class MetadataEntry(
                            metadataEntryId: _root_.java.util.UUID,
                            when: _root_.org.joda.time.DateTime,
                            key: String,
                            value: String
                          )

  /**
    * Pager Duty integration
    */
  case class Pagerduty(
                        serviceKey: String,
                        numConsecutiveFailures: Int = 1,
                        apiUrl: String = "https://events.pagerduty.com"
                      ) extends Notification

  case class Process(
                      processId: _root_.java.util.UUID,
                      processDefinitionName: String,
                      startTime: _root_.org.joda.time.DateTime,
                      status: com.gilt.svc.sundial.v0.models.ProcessStatus,
                      task: Seq[com.gilt.svc.sundial.v0.models.Task]
                    )

  /**
    * A grouping of related tasks that are run as a single unit on the same schedule
    * @param overlapAction
    * @param processDescription
    * @param taskDefinitions
    * @param paused If true, ignore schedule and only start process if triggered
    * manually
    * @param schedule The schedule that the process runs on; if not specified, the
    * process will only run when triggered manually
    * @param processDefinitionName
    * @param notifications
    */
  case class ProcessDefinition(
                                processDefinitionName: String,
                                paused: _root_.scala.Option[Boolean] = None,
                                processDescription: _root_.scala.Option[String] = None,
                                schedule: _root_.scala.Option[com.gilt.svc.sundial.v0.models.ProcessSchedule] = None,
                                taskDefinitions: Seq[com.gilt.svc.sundial.v0.models.TaskDefinition],
                                overlapAction: com.gilt.svc.sundial.v0.models.ProcessOverlapAction = com.gilt.svc.sundial.v0.models.ProcessOverlapAction.Wait,
                                notifications: _root_.scala.Option[Seq[com.gilt.svc.sundial.v0.models.Notification]] = None
                              )

  case class ShellScriptCommand(
                                 script: String,
                                 environmentVariables: _root_.scala.Option[Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable]] = None
                               ) extends TaskExecutable

  /**
    * @param startTime
    * @param taskDefinitionName
    * @param logEntries
    * @param previousAttemptCount
    * @param endTime
    * @param status
    * @param metadataEntries
    * @param processDefinitionName
    * @param executionState Internal bookkeeping metadata used for task scheduling
    * (e.g. ECS task ID and cluster name)
    * @param taskId
    * @param processId
    */
  case class Task(
                   taskId: _root_.java.util.UUID,
                   processId: _root_.java.util.UUID,
                   processDefinitionName: String,
                   taskDefinitionName: String,
                   startTime: _root_.org.joda.time.DateTime,
                   endTime: _root_.scala.Option[_root_.org.joda.time.DateTime] = None,
                   previousAttemptCount: Int,
                   logEntries: Seq[com.gilt.svc.sundial.v0.models.LogEntry],
                   metadataEntries: Seq[com.gilt.svc.sundial.v0.models.MetadataEntry],
                   executionState: _root_.scala.Option[Seq[com.gilt.svc.sundial.v0.models.MetadataEntry]] = None,
                   status: com.gilt.svc.sundial.v0.models.TaskStatus
                 )

  /**
    * An individual task that runs as part of a process
    * @param taskDefinitionName The canonical name for this task used by other tasks
    * to identify this task
    * @param requireExplicitSuccess If true, the task must explicitly update its
    * status with Sundial in order to succeed.
    * @param maxRuntimeSeconds The execution time (for a single attempt) after which
    * the system will kill the task
    * @param maxAttempts
    * @param backoffExponent
    * @param backoffBaseSeconds
    * @param dependencies The tasks that must have completed prior to this one
    * beginning
    * @param executable
    */
  case class TaskDefinition(
                             taskDefinitionName: String,
                             dependencies: Seq[com.gilt.svc.sundial.v0.models.TaskDependency],
                             executable: com.gilt.svc.sundial.v0.models.TaskExecutable,
                             maxAttempts: Int,
                             maxRuntimeSeconds: _root_.scala.Option[Int] = None,
                             backoffBaseSeconds: Int,
                             backoffExponent: Double = 1.0,
                             requireExplicitSuccess: Boolean
                           )

  case class TaskDependency(
                             taskDefinitionName: String,
                             successRequired: Boolean = true
                           )

  /**
    * Provides future compatibility in clients - in the future, when a type is added
    * to the union Notification, it will need to be handled in the client code. This
    * implementation will deserialize these future types as an instance of this class.
    * @param description Information about the type that we received that is undefined
    * in this version of the client.
    */
  case class NotificationUndefinedType(
                                        description: String
                                      ) extends Notification

  /**
    * Provides future compatibility in clients - in the future, when a type is added
    * to the union ProcessSchedule, it will need to be handled in the client code.
    * This implementation will deserialize these future types as an instance of this
    * class.
    * @param description Information about the type that we received that is undefined
    * in this version of the client.
    */
  case class ProcessScheduleUndefinedType(
                                           description: String
                                         ) extends ProcessSchedule

  /**
    * Provides future compatibility in clients - in the future, when a type is added
    * to the union TaskExecutable, it will need to be handled in the client code. This
    * implementation will deserialize these future types as an instance of this class.
    * @param description Information about the type that we received that is undefined
    * in this version of the client.
    */
  case class TaskExecutableUndefinedType(
                                          description: String
                                        ) extends TaskExecutable

  sealed trait NotificationOptions extends _root_.scala.Product with _root_.scala.Serializable

  object NotificationOptions {

    /**
      * Always notify when a process completes
      */
    case object Always extends NotificationOptions { override def toString = "always" }
    /**
      * Notify when a process fails
      */
    case object OnFailure extends NotificationOptions { override def toString = "on_failure" }
    /**
      * Notify when a process goes from succeeding to failing and vica versa
      */
    case object OnStateChange extends NotificationOptions { override def toString = "on_state_change" }
    /**
      * Notify when going from failing to succeeded and on each failure
      */
    case object OnStateChangeAndFailures extends NotificationOptions { override def toString = "on_state_change_and_failures" }
    /**
      * Never notify
      */
    case object Never extends NotificationOptions { override def toString = "never" }

    /**
      * UNDEFINED captures values that are sent either in error or
      * that were added by the server after this library was
      * generated. We want to make it easy and obvious for users of
      * this library to handle this case gracefully.
      *
      * We use all CAPS for the variable name to avoid collisions
      * with the camel cased values above.
      */
    case class UNDEFINED(override val toString: String) extends NotificationOptions

    /**
      * all returns a list of all the valid, known values. We use
      * lower case to avoid collisions with the camel cased values
      * above.
      */
    val all = Seq(Always, OnFailure, OnStateChange, OnStateChangeAndFailures, Never)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): NotificationOptions = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[NotificationOptions] = byName.get(value.toLowerCase)

  }

  sealed trait ProcessOverlapAction extends _root_.scala.Product with _root_.scala.Serializable

  object ProcessOverlapAction {

    /**
      * The process should wait until the currently running instance finishes
      */
    case object Wait extends ProcessOverlapAction { override def toString = "wait" }
    /**
      * The currently running process should be killed
      */
    case object Terminate extends ProcessOverlapAction { override def toString = "terminate" }

    /**
      * UNDEFINED captures values that are sent either in error or
      * that were added by the server after this library was
      * generated. We want to make it easy and obvious for users of
      * this library to handle this case gracefully.
      *
      * We use all CAPS for the variable name to avoid collisions
      * with the camel cased values above.
      */
    case class UNDEFINED(override val toString: String) extends ProcessOverlapAction

    /**
      * all returns a list of all the valid, known values. We use
      * lower case to avoid collisions with the camel cased values
      * above.
      */
    val all = Seq(Wait, Terminate)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ProcessOverlapAction = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ProcessOverlapAction] = byName.get(value.toLowerCase)

  }

  sealed trait ProcessStatus extends _root_.scala.Product with _root_.scala.Serializable

  object ProcessStatus {

    /**
      * The process has tasks currently executing
      */
    case object Running extends ProcessStatus { override def toString = "running" }
    /**
      * All of the process's tasks succeeded on its last run
      */
    case object Succeeded extends ProcessStatus { override def toString = "succeeded" }
    /**
      * At least one of the process's tasks failed on its last run
      */
    case object Failed extends ProcessStatus { override def toString = "failed" }

    /**
      * UNDEFINED captures values that are sent either in error or
      * that were added by the server after this library was
      * generated. We want to make it easy and obvious for users of
      * this library to handle this case gracefully.
      *
      * We use all CAPS for the variable name to avoid collisions
      * with the camel cased values above.
      */
    case class UNDEFINED(override val toString: String) extends ProcessStatus

    /**
      * all returns a list of all the valid, known values. We use
      * lower case to avoid collisions with the camel cased values
      * above.
      */
    val all = Seq(Running, Succeeded, Failed)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ProcessStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ProcessStatus] = byName.get(value.toLowerCase)

  }

  sealed trait TaskStatus extends _root_.scala.Product with _root_.scala.Serializable

  object TaskStatus {

    /**
      * The task has been submitted
      */
    case object Submitted extends TaskStatus { override def toString = "submitted" }
    case object Runnable extends TaskStatus { override def toString = "runnable" }
    case object Starting extends TaskStatus { override def toString = "starting" }
    /**
      * The task is waiting on compute resources
      */
    case object Pending extends TaskStatus { override def toString = "pending" }
    /**
      * The task is currently executing or awaiting backoff
      */
    case object Running extends TaskStatus { override def toString = "running" }
    /**
      * The task has irrevocably failed
      */
    case object Failed extends TaskStatus { override def toString = "failed" }
    /**
      * The task has succeeded without serious errors
      */
    case object Succeeded extends TaskStatus { override def toString = "succeeded" }

    /**
      * UNDEFINED captures values that are sent either in error or
      * that were added by the server after this library was
      * generated. We want to make it easy and obvious for users of
      * this library to handle this case gracefully.
      *
      * We use all CAPS for the variable name to avoid collisions
      * with the camel cased values above.
      */
    case class UNDEFINED(override val toString: String) extends TaskStatus

    /**
      * all returns a list of all the valid, known values. We use
      * lower case to avoid collisions with the camel cased values
      * above.
      */
    val all = Seq(Submitted, Runnable, Starting, Pending, Running, Failed, Succeeded)

    private[this]
    val byName = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): TaskStatus = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[TaskStatus] = byName.get(value.toLowerCase)

  }

}

package com.gilt.svc.sundial.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import com.gilt.svc.sundial.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsSvcSundialNotificationOptions = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.NotificationOptions] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.NotificationOptions] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.NotificationOptions(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.NotificationOptions(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialNotificationOptions(obj: com.gilt.svc.sundial.v0.models.NotificationOptions) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectNotificationOptions(obj: com.gilt.svc.sundial.v0.models.NotificationOptions) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialNotificationOptions: play.api.libs.json.Writes[NotificationOptions] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.NotificationOptions] {
        def writes(obj: com.gilt.svc.sundial.v0.models.NotificationOptions) = {
          jsonWritesSvcSundialNotificationOptions(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialProcessOverlapAction = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessOverlapAction(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessOverlapAction(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialProcessOverlapAction(obj: com.gilt.svc.sundial.v0.models.ProcessOverlapAction) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectProcessOverlapAction(obj: com.gilt.svc.sundial.v0.models.ProcessOverlapAction) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialProcessOverlapAction: play.api.libs.json.Writes[ProcessOverlapAction] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessOverlapAction) = {
          jsonWritesSvcSundialProcessOverlapAction(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialProcessStatus = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.ProcessStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.ProcessStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialProcessStatus(obj: com.gilt.svc.sundial.v0.models.ProcessStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectProcessStatus(obj: com.gilt.svc.sundial.v0.models.ProcessStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialProcessStatus: play.api.libs.json.Writes[ProcessStatus] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessStatus] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessStatus) = {
          jsonWritesSvcSundialProcessStatus(obj)
        }
      }
    }

    implicit val jsonReadsSvcSundialTaskStatus = new play.api.libs.json.Reads[com.gilt.svc.sundial.v0.models.TaskStatus] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[com.gilt.svc.sundial.v0.models.TaskStatus] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.TaskStatus(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.TaskStatus(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesSvcSundialTaskStatus(obj: com.gilt.svc.sundial.v0.models.TaskStatus) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectTaskStatus(obj: com.gilt.svc.sundial.v0.models.TaskStatus) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesSvcSundialTaskStatus: play.api.libs.json.Writes[TaskStatus] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskStatus] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskStatus) = {
          jsonWritesSvcSundialTaskStatus(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialBatchImageCommand: play.api.libs.json.Reads[BatchImageCommand] = {
      (
        (__ \ "image").read[String] and
          (__ \ "tag").read[String] and
          (__ \ "command").read[Seq[String]] and
          (__ \ "memory").read[Int] and
          (__ \ "vCpus").read[Int] and
          (__ \ "job_role_arn").readNullable[String] and
          (__ \ "environment_variables").read[Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable]] and
          (__ \ "job_queue").readNullable[String]
        )(BatchImageCommand.apply _)
    }

    def jsObjectBatchImageCommand(obj: com.gilt.svc.sundial.v0.models.BatchImageCommand): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "image" -> play.api.libs.json.JsString(obj.image),
        "tag" -> play.api.libs.json.JsString(obj.tag),
        "command" -> play.api.libs.json.Json.toJson(obj.command),
        "memory" -> play.api.libs.json.JsNumber(obj.memory),
        "vCpus" -> play.api.libs.json.JsNumber(obj.vCpus),
        "environment_variables" -> play.api.libs.json.Json.toJson(obj.environmentVariables)
      ) ++ (obj.jobRoleArn match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("job_role_arn" -> play.api.libs.json.JsString(x))
      }) ++
        (obj.jobQueue match {
          case None => play.api.libs.json.Json.obj()
          case Some(x) => play.api.libs.json.Json.obj("job_queue" -> play.api.libs.json.JsString(x))
        })
    }

    implicit def jsonReadsSvcSundialContinuousSchedule: play.api.libs.json.Reads[ContinuousSchedule] = {
      (__ \ "buffer_seconds").readNullable[Int].map { x => new ContinuousSchedule(bufferSeconds = x) }
    }

    def jsObjectContinuousSchedule(obj: com.gilt.svc.sundial.v0.models.ContinuousSchedule): play.api.libs.json.JsObject = {
      (obj.bufferSeconds match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("buffer_seconds" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonReadsSvcSundialCronSchedule: play.api.libs.json.Reads[CronSchedule] = {
      (
        (__ \ "day_of_week").read[String] and
          (__ \ "month").read[String] and
          (__ \ "day_of_month").read[String] and
          (__ \ "hours").read[String] and
          (__ \ "minutes").read[String]
        )(CronSchedule.apply _)
    }

    def jsObjectCronSchedule(obj: com.gilt.svc.sundial.v0.models.CronSchedule): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "day_of_week" -> play.api.libs.json.JsString(obj.dayOfWeek),
        "month" -> play.api.libs.json.JsString(obj.month),
        "day_of_month" -> play.api.libs.json.JsString(obj.dayOfMonth),
        "hours" -> play.api.libs.json.JsString(obj.hours),
        "minutes" -> play.api.libs.json.JsString(obj.minutes)
      )
    }

    implicit def jsonReadsSvcSundialDockerImageCommand: play.api.libs.json.Reads[DockerImageCommand] = {
      (
        (__ \ "image").read[String] and
          (__ \ "tag").read[String] and
          (__ \ "command").read[Seq[String]] and
          (__ \ "memory").readNullable[Int] and
          (__ \ "cpu").readNullable[Int] and
          (__ \ "taskRoleArn").readNullable[String] and
          (__ \ "log_paths").read[Seq[String]] and
          (__ \ "environment_variables").read[Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable]]
        )(DockerImageCommand.apply _)
    }

    def jsObjectDockerImageCommand(obj: com.gilt.svc.sundial.v0.models.DockerImageCommand): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "image" -> play.api.libs.json.JsString(obj.image),
        "tag" -> play.api.libs.json.JsString(obj.tag),
        "command" -> play.api.libs.json.Json.toJson(obj.command),
        "log_paths" -> play.api.libs.json.Json.toJson(obj.logPaths),
        "environment_variables" -> play.api.libs.json.Json.toJson(obj.environmentVariables)
      ) ++ (obj.memory match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("memory" -> play.api.libs.json.JsNumber(x))
      }) ++
        (obj.cpu match {
          case None => play.api.libs.json.Json.obj()
          case Some(x) => play.api.libs.json.Json.obj("cpu" -> play.api.libs.json.JsNumber(x))
        }) ++
        (obj.taskRoleArn match {
          case None => play.api.libs.json.Json.obj()
          case Some(x) => play.api.libs.json.Json.obj("taskRoleArn" -> play.api.libs.json.JsString(x))
        })
    }

    implicit def jsonReadsSvcSundialEmail: play.api.libs.json.Reads[Email] = {
      (
        (__ \ "name").read[String] and
          (__ \ "email").read[String] and
          (__ \ "notify_when").read[com.gilt.svc.sundial.v0.models.NotificationOptions]
        )(Email.apply _)
    }

    def jsObjectEmail(obj: com.gilt.svc.sundial.v0.models.Email): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "email" -> play.api.libs.json.JsString(obj.email),
        "notify_when" -> play.api.libs.json.JsString(obj.notifyWhen.toString)
      )
    }

    implicit def jsonReadsSvcSundialEnvironmentVariable: play.api.libs.json.Reads[EnvironmentVariable] = {
      (
        (__ \ "variable_name").read[String] and
          (__ \ "value").read[String]
        )(EnvironmentVariable.apply _)
    }

    def jsObjectEnvironmentVariable(obj: com.gilt.svc.sundial.v0.models.EnvironmentVariable): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "variable_name" -> play.api.libs.json.JsString(obj.variableName),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesSvcSundialEnvironmentVariable: play.api.libs.json.Writes[EnvironmentVariable] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.EnvironmentVariable] {
        def writes(obj: com.gilt.svc.sundial.v0.models.EnvironmentVariable) = {
          jsObjectEnvironmentVariable(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialHealthcheck: play.api.libs.json.Reads[Healthcheck] = {
      (__ \ "status").read[String].map { x => new Healthcheck(status = x) }
    }

    def jsObjectHealthcheck(obj: com.gilt.svc.sundial.v0.models.Healthcheck): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "status" -> play.api.libs.json.JsString(obj.status)
      )
    }

    implicit def jsonWritesSvcSundialHealthcheck: play.api.libs.json.Writes[Healthcheck] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.Healthcheck] {
        def writes(obj: com.gilt.svc.sundial.v0.models.Healthcheck) = {
          jsObjectHealthcheck(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialLogEntry: play.api.libs.json.Reads[LogEntry] = {
      (
        (__ \ "log_entry_id").read[_root_.java.util.UUID] and
          (__ \ "when").read[_root_.org.joda.time.DateTime] and
          (__ \ "source").read[String] and
          (__ \ "message").read[String]
        )(LogEntry.apply _)
    }

    def jsObjectLogEntry(obj: com.gilt.svc.sundial.v0.models.LogEntry): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "log_entry_id" -> play.api.libs.json.JsString(obj.logEntryId.toString),
        "when" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.when)),
        "source" -> play.api.libs.json.JsString(obj.source),
        "message" -> play.api.libs.json.JsString(obj.message)
      )
    }

    implicit def jsonWritesSvcSundialLogEntry: play.api.libs.json.Writes[LogEntry] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.LogEntry] {
        def writes(obj: com.gilt.svc.sundial.v0.models.LogEntry) = {
          jsObjectLogEntry(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialMetadataEntry: play.api.libs.json.Reads[MetadataEntry] = {
      (
        (__ \ "metadata_entry_id").read[_root_.java.util.UUID] and
          (__ \ "when").read[_root_.org.joda.time.DateTime] and
          (__ \ "key").read[String] and
          (__ \ "value").read[String]
        )(MetadataEntry.apply _)
    }

    def jsObjectMetadataEntry(obj: com.gilt.svc.sundial.v0.models.MetadataEntry): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "metadata_entry_id" -> play.api.libs.json.JsString(obj.metadataEntryId.toString),
        "when" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.when)),
        "key" -> play.api.libs.json.JsString(obj.key),
        "value" -> play.api.libs.json.JsString(obj.value)
      )
    }

    implicit def jsonWritesSvcSundialMetadataEntry: play.api.libs.json.Writes[MetadataEntry] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.MetadataEntry] {
        def writes(obj: com.gilt.svc.sundial.v0.models.MetadataEntry) = {
          jsObjectMetadataEntry(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialPagerduty: play.api.libs.json.Reads[Pagerduty] = {
      (
        (__ \ "service_key").read[String] and
          (__ \ "num_consecutive_failures").read[Int] and
          (__ \ "api_url").read[String]
        )(Pagerduty.apply _)
    }

    def jsObjectPagerduty(obj: com.gilt.svc.sundial.v0.models.Pagerduty): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "service_key" -> play.api.libs.json.JsString(obj.serviceKey),
        "num_consecutive_failures" -> play.api.libs.json.JsNumber(obj.numConsecutiveFailures),
        "api_url" -> play.api.libs.json.JsString(obj.apiUrl)
      )
    }

    implicit def jsonReadsSvcSundialProcess: play.api.libs.json.Reads[Process] = {
      (
        (__ \ "process_id").read[_root_.java.util.UUID] and
          (__ \ "process_definition_name").read[String] and
          (__ \ "start_time").read[_root_.org.joda.time.DateTime] and
          (__ \ "status").read[com.gilt.svc.sundial.v0.models.ProcessStatus] and
          (__ \ "task").read[Seq[com.gilt.svc.sundial.v0.models.Task]]
        )(Process.apply _)
    }

    def jsObjectProcess(obj: com.gilt.svc.sundial.v0.models.Process): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "process_id" -> play.api.libs.json.JsString(obj.processId.toString),
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "start_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.startTime)),
        "status" -> play.api.libs.json.JsString(obj.status.toString),
        "task" -> play.api.libs.json.Json.toJson(obj.task)
      )
    }

    implicit def jsonWritesSvcSundialProcess: play.api.libs.json.Writes[Process] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.Process] {
        def writes(obj: com.gilt.svc.sundial.v0.models.Process) = {
          jsObjectProcess(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialProcessDefinition: play.api.libs.json.Reads[ProcessDefinition] = {
      (
        (__ \ "process_definition_name").read[String] and
          (__ \ "paused").readNullable[Boolean] and
          (__ \ "process_description").readNullable[String] and
          (__ \ "schedule").readNullable[com.gilt.svc.sundial.v0.models.ProcessSchedule] and
          (__ \ "task_definitions").read[Seq[com.gilt.svc.sundial.v0.models.TaskDefinition]] and
          (__ \ "overlap_action").read[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] and
          (__ \ "notifications").readNullable[Seq[com.gilt.svc.sundial.v0.models.Notification]]
        )(ProcessDefinition.apply _)
    }

    def jsObjectProcessDefinition(obj: com.gilt.svc.sundial.v0.models.ProcessDefinition): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "task_definitions" -> play.api.libs.json.Json.toJson(obj.taskDefinitions),
        "overlap_action" -> play.api.libs.json.JsString(obj.overlapAction.toString)
      ) ++ (obj.paused match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("paused" -> play.api.libs.json.JsBoolean(x))
      }) ++
        (obj.processDescription match {
          case None => play.api.libs.json.Json.obj()
          case Some(x) => play.api.libs.json.Json.obj("process_description" -> play.api.libs.json.JsString(x))
        }) ++
        (obj.schedule match {
          case None => play.api.libs.json.Json.obj()
          case Some(x) => play.api.libs.json.Json.obj("schedule" -> jsObjectProcessSchedule(x))
        }) ++
        (obj.notifications match {
          case None => play.api.libs.json.Json.obj()
          case Some(x) => play.api.libs.json.Json.obj("notifications" -> play.api.libs.json.Json.toJson(x))
        })
    }

    implicit def jsonWritesSvcSundialProcessDefinition: play.api.libs.json.Writes[ProcessDefinition] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessDefinition] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessDefinition) = {
          jsObjectProcessDefinition(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialShellScriptCommand: play.api.libs.json.Reads[ShellScriptCommand] = {
      (
        (__ \ "script").read[String] and
          (__ \ "environment_variables").readNullable[Seq[com.gilt.svc.sundial.v0.models.EnvironmentVariable]]
        )(ShellScriptCommand.apply _)
    }

    def jsObjectShellScriptCommand(obj: com.gilt.svc.sundial.v0.models.ShellScriptCommand): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "script" -> play.api.libs.json.JsString(obj.script)
      ) ++ (obj.environmentVariables match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("environment_variables" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsSvcSundialTask: play.api.libs.json.Reads[Task] = {
      (
        (__ \ "task_id").read[_root_.java.util.UUID] and
          (__ \ "process_id").read[_root_.java.util.UUID] and
          (__ \ "process_definition_name").read[String] and
          (__ \ "task_definition_name").read[String] and
          (__ \ "start_time").read[_root_.org.joda.time.DateTime] and
          (__ \ "end_time").readNullable[_root_.org.joda.time.DateTime] and
          (__ \ "previous_attempt_count").read[Int] and
          (__ \ "log_entries").read[Seq[com.gilt.svc.sundial.v0.models.LogEntry]] and
          (__ \ "metadata_entries").read[Seq[com.gilt.svc.sundial.v0.models.MetadataEntry]] and
          (__ \ "execution_state").readNullable[Seq[com.gilt.svc.sundial.v0.models.MetadataEntry]] and
          (__ \ "status").read[com.gilt.svc.sundial.v0.models.TaskStatus]
        )(Task.apply _)
    }

    def jsObjectTask(obj: com.gilt.svc.sundial.v0.models.Task): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "task_id" -> play.api.libs.json.JsString(obj.taskId.toString),
        "process_id" -> play.api.libs.json.JsString(obj.processId.toString),
        "process_definition_name" -> play.api.libs.json.JsString(obj.processDefinitionName),
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "start_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(obj.startTime)),
        "previous_attempt_count" -> play.api.libs.json.JsNumber(obj.previousAttemptCount),
        "log_entries" -> play.api.libs.json.Json.toJson(obj.logEntries),
        "metadata_entries" -> play.api.libs.json.Json.toJson(obj.metadataEntries),
        "status" -> play.api.libs.json.JsString(obj.status.toString)
      ) ++ (obj.endTime match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("end_time" -> play.api.libs.json.JsString(_root_.org.joda.time.format.ISODateTimeFormat.dateTime.print(x)))
      }) ++
        (obj.executionState match {
          case None => play.api.libs.json.Json.obj()
          case Some(x) => play.api.libs.json.Json.obj("execution_state" -> play.api.libs.json.Json.toJson(x))
        })
    }

    implicit def jsonWritesSvcSundialTask: play.api.libs.json.Writes[Task] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.Task] {
        def writes(obj: com.gilt.svc.sundial.v0.models.Task) = {
          jsObjectTask(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskDefinition: play.api.libs.json.Reads[TaskDefinition] = {
      (
        (__ \ "task_definition_name").read[String] and
          (__ \ "dependencies").read[Seq[com.gilt.svc.sundial.v0.models.TaskDependency]] and
          (__ \ "executable").read[com.gilt.svc.sundial.v0.models.TaskExecutable] and
          (__ \ "max_attempts").read[Int] and
          (__ \ "max_runtime_seconds").readNullable[Int] and
          (__ \ "backoff_base_seconds").read[Int] and
          (__ \ "backoff_exponent").read[Double] and
          (__ \ "require_explicit_success").read[Boolean]
        )(TaskDefinition.apply _)
    }

    def jsObjectTaskDefinition(obj: com.gilt.svc.sundial.v0.models.TaskDefinition): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "dependencies" -> play.api.libs.json.Json.toJson(obj.dependencies),
        "executable" -> jsObjectTaskExecutable(obj.executable),
        "max_attempts" -> play.api.libs.json.JsNumber(obj.maxAttempts),
        "backoff_base_seconds" -> play.api.libs.json.JsNumber(obj.backoffBaseSeconds),
        "backoff_exponent" -> play.api.libs.json.JsNumber(obj.backoffExponent),
        "require_explicit_success" -> play.api.libs.json.JsBoolean(obj.requireExplicitSuccess)
      ) ++ (obj.maxRuntimeSeconds match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("max_runtime_seconds" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesSvcSundialTaskDefinition: play.api.libs.json.Writes[TaskDefinition] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskDefinition] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskDefinition) = {
          jsObjectTaskDefinition(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskDependency: play.api.libs.json.Reads[TaskDependency] = {
      (
        (__ \ "task_definition_name").read[String] and
          (__ \ "success_required").read[Boolean]
        )(TaskDependency.apply _)
    }

    def jsObjectTaskDependency(obj: com.gilt.svc.sundial.v0.models.TaskDependency): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "task_definition_name" -> play.api.libs.json.JsString(obj.taskDefinitionName),
        "success_required" -> play.api.libs.json.JsBoolean(obj.successRequired)
      )
    }

    implicit def jsonWritesSvcSundialTaskDependency: play.api.libs.json.Writes[TaskDependency] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskDependency] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskDependency) = {
          jsObjectTaskDependency(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialNotification: play.api.libs.json.Reads[Notification] = {
      (
        (__ \ "email").read(jsonReadsSvcSundialEmail).asInstanceOf[play.api.libs.json.Reads[Notification]]
          orElse
          (__ \ "pagerduty").read(jsonReadsSvcSundialPagerduty).asInstanceOf[play.api.libs.json.Reads[Notification]]
          orElse
          play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.NotificationUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[Notification]]
        )
    }

    def jsObjectNotification(obj: com.gilt.svc.sundial.v0.models.Notification): play.api.libs.json.JsObject = {
      obj match {
        case x: com.gilt.svc.sundial.v0.models.Email => play.api.libs.json.Json.obj("email" -> jsObjectEmail(x))
        case x: com.gilt.svc.sundial.v0.models.Pagerduty => play.api.libs.json.Json.obj("pagerduty" -> jsObjectPagerduty(x))
        case x: com.gilt.svc.sundial.v0.models.NotificationUndefinedType => sys.error(s"The type[com.gilt.svc.sundial.v0.models.NotificationUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialNotification: play.api.libs.json.Writes[Notification] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.Notification] {
        def writes(obj: com.gilt.svc.sundial.v0.models.Notification) = {
          jsObjectNotification(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialProcessSchedule: play.api.libs.json.Reads[ProcessSchedule] = {
      (
        (__ \ "cron_schedule").read(jsonReadsSvcSundialCronSchedule).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
          orElse
          (__ \ "continuous_schedule").read(jsonReadsSvcSundialContinuousSchedule).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
          orElse
          play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.ProcessScheduleUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[ProcessSchedule]]
        )
    }

    def jsObjectProcessSchedule(obj: com.gilt.svc.sundial.v0.models.ProcessSchedule): play.api.libs.json.JsObject = {
      obj match {
        case x: com.gilt.svc.sundial.v0.models.CronSchedule => play.api.libs.json.Json.obj("cron_schedule" -> jsObjectCronSchedule(x))
        case x: com.gilt.svc.sundial.v0.models.ContinuousSchedule => play.api.libs.json.Json.obj("continuous_schedule" -> jsObjectContinuousSchedule(x))
        case x: com.gilt.svc.sundial.v0.models.ProcessScheduleUndefinedType => sys.error(s"The type[com.gilt.svc.sundial.v0.models.ProcessScheduleUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialProcessSchedule: play.api.libs.json.Writes[ProcessSchedule] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.ProcessSchedule] {
        def writes(obj: com.gilt.svc.sundial.v0.models.ProcessSchedule) = {
          jsObjectProcessSchedule(obj)
        }
      }
    }

    implicit def jsonReadsSvcSundialTaskExecutable: play.api.libs.json.Reads[TaskExecutable] = {
      (
        (__ \ "docker_image_command").read(jsonReadsSvcSundialDockerImageCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
          orElse
          (__ \ "shell_script_command").read(jsonReadsSvcSundialShellScriptCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
          orElse
          (__ \ "batch_image_command").read(jsonReadsSvcSundialBatchImageCommand).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
          orElse
          play.api.libs.json.Reads(jsValue => play.api.libs.json.JsSuccess(com.gilt.svc.sundial.v0.models.TaskExecutableUndefinedType(jsValue.toString))).asInstanceOf[play.api.libs.json.Reads[TaskExecutable]]
        )
    }

    def jsObjectTaskExecutable(obj: com.gilt.svc.sundial.v0.models.TaskExecutable): play.api.libs.json.JsObject = {
      obj match {
        case x: com.gilt.svc.sundial.v0.models.DockerImageCommand => play.api.libs.json.Json.obj("docker_image_command" -> jsObjectDockerImageCommand(x))
        case x: com.gilt.svc.sundial.v0.models.ShellScriptCommand => play.api.libs.json.Json.obj("shell_script_command" -> jsObjectShellScriptCommand(x))
        case x: com.gilt.svc.sundial.v0.models.BatchImageCommand => play.api.libs.json.Json.obj("batch_image_command" -> jsObjectBatchImageCommand(x))
        case x: com.gilt.svc.sundial.v0.models.TaskExecutableUndefinedType => sys.error(s"The type[com.gilt.svc.sundial.v0.models.TaskExecutableUndefinedType] should never be serialized")
      }
    }

    implicit def jsonWritesSvcSundialTaskExecutable: play.api.libs.json.Writes[TaskExecutable] = {
      new play.api.libs.json.Writes[com.gilt.svc.sundial.v0.models.TaskExecutable] {
        def writes(obj: com.gilt.svc.sundial.v0.models.TaskExecutable) = {
          jsObjectTaskExecutable(obj)
        }
      }
    }
  }
}

package com.gilt.svc.sundial.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}
    import org.joda.time.{DateTime, LocalDate}
    import org.joda.time.format.ISODateTimeFormat
    import com.gilt.svc.sundial.v0.models._

    // Type: date-time-iso8601
    implicit val pathBindableTypeDateTimeIso8601 = new PathBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    implicit val queryStringBindableTypeDateTimeIso8601 = new QueryStringBindable.Parsing[org.joda.time.DateTime](
      ISODateTimeFormat.dateTimeParser.parseDateTime(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date time $key. Example: 2014-04-29T11:56:52Z"
    )

    // Type: date-iso8601
    implicit val pathBindableTypeDateIso8601 = new PathBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    implicit val queryStringBindableTypeDateIso8601 = new QueryStringBindable.Parsing[org.joda.time.LocalDate](
      ISODateTimeFormat.yearMonthDay.parseLocalDate(_), _.toString, (key: String, e: _root_.java.lang.Exception) => s"Error parsing date $key. Example: 2014-04-29"
    )

    // Enum: NotificationOptions
    private[this] val enumNotificationOptionsNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.NotificationOptions.all.mkString(", ")}"

    implicit val pathBindableEnumNotificationOptions = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.NotificationOptions] (
      NotificationOptions.fromString(_).get, _.toString, enumNotificationOptionsNotFound
    )

    implicit val queryStringBindableEnumNotificationOptions = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.NotificationOptions](
      NotificationOptions.fromString(_).get, _.toString, enumNotificationOptionsNotFound
    )

    // Enum: ProcessOverlapAction
    private[this] val enumProcessOverlapActionNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.ProcessOverlapAction.all.mkString(", ")}"

    implicit val pathBindableEnumProcessOverlapAction = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessOverlapAction] (
      ProcessOverlapAction.fromString(_).get, _.toString, enumProcessOverlapActionNotFound
    )

    implicit val queryStringBindableEnumProcessOverlapAction = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessOverlapAction](
      ProcessOverlapAction.fromString(_).get, _.toString, enumProcessOverlapActionNotFound
    )

    // Enum: ProcessStatus
    private[this] val enumProcessStatusNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.ProcessStatus.all.mkString(", ")}"

    implicit val pathBindableEnumProcessStatus = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessStatus] (
      ProcessStatus.fromString(_).get, _.toString, enumProcessStatusNotFound
    )

    implicit val queryStringBindableEnumProcessStatus = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.ProcessStatus](
      ProcessStatus.fromString(_).get, _.toString, enumProcessStatusNotFound
    )

    // Enum: TaskStatus
    private[this] val enumTaskStatusNotFound = (key: String, e: _root_.java.lang.Exception) => s"Unrecognized $key, should be one of ${com.gilt.svc.sundial.v0.models.TaskStatus.all.mkString(", ")}"

    implicit val pathBindableEnumTaskStatus = new PathBindable.Parsing[com.gilt.svc.sundial.v0.models.TaskStatus] (
      TaskStatus.fromString(_).get, _.toString, enumTaskStatusNotFound
    )

    implicit val queryStringBindableEnumTaskStatus = new QueryStringBindable.Parsing[com.gilt.svc.sundial.v0.models.TaskStatus](
      TaskStatus.fromString(_).get, _.toString, enumTaskStatusNotFound
    )

  }

}